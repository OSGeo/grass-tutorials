{
  "hash": "2e602dc13f3979dc3d599688a7d634b5",
  "result": {
    "markdown": "---\ntitle: Get started with GRASS & Python in Jupyter Notebooks\nauthor: Veronica Andreo\ndate: '2024-03-25'\ndate-modified: today\nformat:\n  html:\n    toc: true\n    code-tools: true\n    code-copy: true\n    code-fold: false\ncategories:\n  - Python\n  - intermediate\nengine: jupyter\nexecute:\n  eval: false\n---\n\nPython, a widely used general-purpose, high-level programming language provides\na powerful scripting interface for geospatial data processing. Being easy-to-use\nyet powerful, it enables users to efficiently exploit the capabilities of the\nGRASS GIS software. Python scripts for GRASS GIS can be written at high level\n(GRASS GIS tools) as well as at low level (GRASS GIS libraries) through dedicated\ninterfaces. Indeed, GRASS GIS is distributed with a set of\n[python packages](https://grass.osgeo.org/grass-stable/manuals/libpython/index.html)\nto provide functionalities at different levels.\n\nIn this tutorial, we will focus on two packages:\n[`grass.script`](https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html)\nand [`grass.jupyter`](https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html),\nwhich provide Python interface to launch GRASS GIS tools in scripts and offer\nclasses and setup functions for running GRASS GIS in Jupyter Notebooks,\nrespectively.\nWe will show two different use cases:\n\n- A. You are mostly a Python user and only need to run a certain GRASS GIS tool on your spatial data to get a specific output\n- B. You are mostly a GRASS GIS user that wants to use GRASS GIS from a Python environment or combine GRASS GIS with other Python packages.\n\nLet's first go through the main functions of GRASS GIS Python packages.\n\n### Python package `grass.script`\n\nThe **grass.script** package or GRASS GIS Python Scripting Library provides\nfunctions for calling GRASS GIS tools within Python scripts. The most\ncommonly used functions include:\n\n- `run_command`: used when there is no text output or the text output does not need to be further processed\n- `read_command`: used when the output of the tools is of text type\n- `parse_command`: used with tools that output machine readable text output\n- `write_command`: used with tools that expect text input, either in the form of a file or from stdin\n\nThere are several wrapper functions for frequently used tools, too.\nFor example:\n\n- To get info from a raster, script.raster.raster_info() is used: `gs.raster_info('dsm')`\n- To get info of a vector, script.vector.vector_info() is used: `gs.vector_info('roads')`\n- To list the raster in a location, script.core.list_grouped() is used: `gs.list_grouped(type=['raster'])`\n- To obtain the computational region, script.core.region() is used: `gs.region()`\n- To run raster algebra with r.mapcalc, script.raster.mapcalc() is used: `gs.mapcalc()`\n\nThe grass.script package also comes with different functions that are useful\nwhen you are writing your own GRASS GIS tools or converting your scripts or\nworkflows into GRASS GIS tools. Some examples of these functions are:\n`append_uuid`, `use_temp_region`, `del_temp_region`, `parse_key_val`, etc.\n\n:::{.callout-note}\nVisit the grass.script documentation for more details and examples:\n<https://grass.osgeo.org/grass-stable/manuals/libpython/script_intro.html>\n:::\n\n### Python package `grass.jupyter`\n\nThe **grass.jupyter** library improves the integration of GRASS and Jupyter, and\nprovides different classes to facilitate GRASS maps visualization:\n\n- `Map`: 2D rendering\n- `Map3D`: 3D rendering\n- `InteractiveMap`: interactive map visualization with folium or ipyleaflet\n- `SeriesMap`: visualizations of a series of raster or vector maps\n- `TimeSeriesMap`: visualization of space-time datasets\n\n:::{.callout-note}\nVisit the grass.jupyter documentation for more details and examples:\n<https://grass.osgeo.org/grass-stable/manuals/libpython/grass.jupyter.html>\n:::\n\n## Let's get started!\n\n### Setup\nThis tutorial can be run locally. You need to have **GRASS GIS 8.4+** and\n**Jupyter** installed. For part A, please download these\n[Sentinel 2](https://grass.osgeo.org/sampledata/north_carolina/nc_sentinel_utm17n.zip)\nscenes and move the unzipped download into the directory where you are running\nthis tutorial.\nFor part B, we asume that you have downloaded the North Carolina\n[sample dataset](https://grass.osgeo.org/sampledata/north_carolina/nc_basic_spm_grass7.zip),\ni.e., there's an existing GRASS project.\nBe sure you also have the following Python libraries installed in your\nenvironment: `folium` or `ipyleaflet`, `numpy`, `seaborn`, `matplotlib`, `pandas`.\n\nThe first thing we need to do is to\n*import GRASS GIS python packages*. In order to do so, we need to\n*add GRASS GIS python package to PATH*. Let's see how we do that.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n# import standard Python packages\nimport os\nimport sys\nimport subprocess\nfrom pathlib import Path\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# check where GRASS GIS python packages are and add them to PATH\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n```\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# import GRASS GIS python packages\nimport grass.script as gs\nimport grass.jupyter as gj\n```\n:::\n\n\n:::{.callout-note}\nWe recommend Windows users to review how to run [GRASS GIS in Jupyter Notebooks on Windows](JupyterOnWindows_OSGeo4W_Tutorial.qmd).\n:::\n\n\n### A. Use GRASS GIS tools within your Python spatial workflows\n\nNow, let's assume you have some raster data you want to process with GRASS GIS\ntools, eg. Sentinel 2 satellite data, to obtain texture indices. The first thing\nyou'll need to do is to **create a GRASS GIS project** to import your data. As\nwe saw already in a previous [fast track](fast_track.qmd) tutorial, GRASS\nprojects are folders where we store spatial data with the same spatial\nreference. These projects can be placed wherever you want, including a temporary\ndirectory if you are mostly interested in the outputs only.\n\nSo, let's *create a project in a temporary directory* to import, i.e. read, our\ndata with GRASS GIS. The `gs.create_project()` function allows us to create a\nGRASS project passing different information. For example, we can use the EPSG\ncode of the data CRS or directly pass a georeferenced file.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Create a temporary folder where to place our GRASS project\nimport tempfile\ntempdir = tempfile.TemporaryDirectory()\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# Create a project in the temporary directory\ngs.create_project(path=tempdir.name,\n                  name=\"nc_sentinel\",\n                  epsg=\"32617\")\n```\n:::\n\n\nAlternatively, use a georeferenced file to read the spatial reference\ninformation from:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# gs.create_project(path=tempdir.name, name=\"nc_sentinel\", filename=\"path/to/georef/file\", overwrite=True)\n```\n:::\n\n\nNow that we created a project, let's **start a GRASS GIS** session there.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Start GRASS in the recently created project\nsession = gj.init(Path(tempdir.name, \"nc_sentinel\"))\n```\n:::\n\n\nWe are now ready to **import data** into the recently created project. Let's use\na for loop to import all 10 m resolution bands. These are level 2A surface\nreflectance data for blue, green, red and near infrared Sentinel 2 bands.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport shutil\n\nshutil.unpack_archive(\"./nc_sentinel_utm17n/S2A_MSIL2A_20220304T160151_N0400_R097_T17SQV_20220304T215812.zip\", \"./nc_sentinel_utm17n\")\nfiles = sorted(Path('./nc_sentinel_utm17n/S2A_MSIL2A_20220304T160151_N0400_R097_T17SQV_20220304T215812.SAFE/GRANULE/L2A_T17SQV_A034986_20220304T160221/IMG_DATA/R10m').glob('*B*.jp2'))\nfiles\n```\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfor file in files:\n    name = str(file)[-11:-4]\n    print(\"importing \" + name)\n    gs.run_command(\"r.import\", input=file, output=name)\n```\n:::\n\n\nLet's check the files we just imported are there:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ngs.list_grouped(type=\"raster\")[\"PERMANENT\"]\n```\n:::\n\n\nLet's have a quick look at one of the imported bands. We can use the `InteractiveMap`\nclass from the grass.jupyter package to **visualize** it.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nm = gj.InteractiveMap()\nm.add_raster(\"B08_10m\")\nm.show()\n```\n:::\n\n\nNext step is to do some **processing or analysis** with the imported data.\nSince we'll be creating new raster maps, we first\nneed to set our *computational region* to the extent and resolution of one of our\nimported bands.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Set computational region\ngs.run_command(\"g.region\", raster=\"B08_10m\", flags=\"p\")\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nm = gj.InteractiveMap(tiles=\"OpenStreetMap\")\nm.add_raster(\"B08_10m\")\nm.show()\n```\n:::\n\n\nIt is common to estimate texture measures over panchromatic bands. Since\nwe do not have one in Sentinel 2 data, we'll create a synthetic one by averaging\nblue, green and red bands.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Create synthetic pan band\ngs.mapcalc(\"pan = (B02_10m + B03_10m + B04_10m) / 3\")\n```\n:::\n\n\nNow that we have the synthetic pan band, let's estimate some texture measures\nwith the [r.texture](https://grass.osgeo.org/grass-stable/manuals/r.texture.html)\ntool.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ngs.run_command(\"r.texture\",\n              input=\"pan\",\n              output=\"pan\",\n              size=5,\n              method=\"contrast,corr\")\n```\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ngs.list_grouped(type=\"raster\", pattern=\"pan*\")[\"PERMANENT\"]\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nt = gj.InteractiveMap(tiles=\"OpenStreetMap\")\nt.add_raster(\"pan_Contr\")\nt.add_raster(\"pan_Corr\")\nt.show()\n```\n:::\n\n\nFinally, we can **export** our texture maps out of GRASS GIS and use them\nsomewhere else or load them into a webGIS.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ntexture_maps = gs.list_grouped(type=\"raster\", pattern=\"pan_*\")[\"PERMANENT\"]\ntexture_maps\n```\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfor texture in texture_maps:\n    gs.run_command(\"r.out.gdal\", input=texture, output=f\"{texture}.tif\", format=\"GTiff\")\n```\n:::\n\n\nThis use case follows the\nExtract-Transform-Load (ETL) process common in production systems. Indeed, this\napproach allows to include GRASS tools into such workflows. These type of\ntasks could be automatized in scripts to be run without even starting GRASS GIS\nusing the `--exec` tool... but that's material for a different tutorial :)\n\n### B. Use Python tools within GRASS GIS workflows\n\nThis case is more relevant for GRASS users who want to combine GRASS GIS\nwith other Python tools for their data processing and analysis workflows.\n\nSeveral GRASS users store most or all of their projects in a single folder,\nwhich has traditionally been called `grassdata`. When this is the case, to\n**start GRASS GIS in an existing project**, we also need to provide the path\nto such a folder.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Start GRASS\nsession = gj.init(\"~/grassdata/nc_basic_spm_grass7/PERMANENT\")\n# alternatively\n# session = gj.init(\"~/grassdata/nc_basic_spm_grass7\")\n# session = gj.init(\"~/grassdata\", \"nc_basic_spm_grass7\", \"PERMANENT\")\n```\n:::\n\n\nWe are now within a GRASS project, let's **obtain information** about it, like\nCRS details, region settings, list of raster and vector maps, etc.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Print project's CRS\ngs.parse_command(\"g.proj\", flags=\"g\")[\"srid\"]\n```\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Print computational region\ngs.region()\n```\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# List raster maps\ngs.list_grouped([\"raster\"])\n```\n:::\n\n\nLet's obtain metadata about the *elevation* raster map.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n# Raster info\ngs.raster_info(\"elevation\")\n```\n:::\n\n\nIf we would only need to know or use the minimum value of the *elevation* raster,\nwe can get it as follows:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ngs.raster_info(\"elevation\")[\"min\"]\n```\n:::\n\n\nLet's now **visualize** raster and vector maps with a different `grass.jupyter`\nclass, the non-interactive `Map` class. This class creates and displays GRASS\nmaps as PNG files. We basically instantiate the class first, add maps and maps'\nelements and finally show the result. There are 2 ways of calling display\n(`d.*`) modules:\n\n- replace `.` by `_` as in `m.d_rast()`\n- use `run()` as in `m.run(\"d.rast\")`\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n# Instantiate the Map class\nm = gj.Map(width=400)\n```\n:::\n\n\nThe *Map* class will by default use the first raster or vector extent to set the\ndisplay extent. You could however also use the current computational region with\n`use_region=True` or call a previously saved computational region (different\nthan the current) with the argument `saved_region`.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\n# Add maps and map elements\nm.d_rast(map=\"elevation\")\nm.d_vect(map=\"streams\")\nm.d_legend(raster=\"elevation\", at=(50, 95, 85, 90), flags=\"b\")\n```\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Display the result\nm.show()\n```\n:::\n\n\nWe can save our displayed maps by calling the `save()` method, i.e., `m.save()`.\nFor the Map class it will output a PNG file, while for the InteractiveMap class\nan HTML.\n\n#### GRASS GIS & NumPy\n\nLet's now see how to convert our **GRASS rasters into numpy arrays**. Having our\nraster maps as numpy arrays opens up a world of possibilities in terms of\nvisualization and data analysis and modeling. We won't go into anything complex\nhere, but we'll show how to read rasters into numpy arrays, plot them, modify\nthem and then write them back into GRASS.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Import required libraries\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom grass.script import array as garray\n```\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Read elevation as numpy array\nelev = garray.array(mapname=\"elevation\", null=\"nan\")\nprint(elev.shape)\n```\n:::\n\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Estimate array average\nprint(np.average(elev))\n```\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\n# Plot elev histogram\nsns.set_style('darkgrid')\nsns.histplot(data=elev.ravel(), labkde=True)\n```\n:::\n\n\nLet's modify our array and write it back into GRASS GIS. For this, we create a\nnew copy of the GRASS elevation map first as shown below.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nelev_2 = garray.array(mapname=\"elevation\")\nelev_2 *= 2\n```\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Plot elev*2\nsns.histplot(data=[elev.ravel(), elev_2.ravel()], kde=True)\nplt.legend(labels=[\"elevation * 2\", \"elevation\"])\n```\n:::\n\n\n![](images/grass_python_histogram.png){.preview-image}\n\nNow we write the modified array into a GRASS raster map and check it's actually\nthere.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nelev_2.write(mapname=\"elevation_2\", overwrite=True)\n```\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ngs.list_grouped(type=\"raster\", pattern=\"elev*\")\n```\n:::\n\n\n#### GRASS GIS & Pandas\n\nLet's now explore how to convert text outputs into pandas data frames. We will\nget elevation univariate statistics for each land use class and parse the output\ninto a pandas data frame.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nimport pandas as pd\nfrom io import StringIO\n```\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nstats = gs.read_command(\"r.univar\",\n                        flags=\"t\",\n                        map=\"elevation\",\n                        zones=\"landuse\",\n                        separator=\"comma\")\ndf = pd.read_csv(StringIO(stats))\n\ndf\n```\n:::\n\n\nNext, we plot the mean elevation per class as follows:\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nplt.figure(figsize=(10, 5))\nplt.bar(df['label'], df['mean'])\nplt.ylabel('Elevation')\nplt.title('Mean elevation by land cover type')\nplt.xticks(rotation=90)\nplt.show()\n```\n:::\n\n\nSimilarly, if we need to do analysis with the attributes of GRASS vector maps,\nit is also possible to read the attribute table as a pandas data frame. Let's\nsee an example with the census vector map:\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\ncensus = gs.parse_command(\"v.db.select\", map=\"census\", format=\"json\")[\"records\"]\ndf = pd.DataFrame(census)\ndf\n```\n:::\n\n\nOnce the attribute table is a data frame, we can, e.g., filter data by a\ncondition and plot the results.\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nfam_size_3 = df[df[\"FAM_SIZE\"] > 3.0]\n```\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nfam_size_3.plot.scatter(x=\"FAM_SIZE\", y=\"OWNER_U\")\n```\n:::\n\n\n## Final remarks\n\nIn this tutorial, we have demonstrated, with very simple examples, how to use\nGRASS GIS tools together with Python, putting a special focus on data import\nand export as well as format conversions. Expert GRASS or Python users can then\nimplement their workflows combining tools accordingly.\n\n**Enjoy!** {{< fa rocket >}}\n\n\n***\n:::{.smaller}\nThe development of this tutorial was funded by the US\n[National Science Foundation (NSF)](https://www.nsf.gov/),\naward [2303651](https://www.nsf.gov/awardsearch/showAward?AWD_ID=2303651).\n:::\n\n",
    "supporting": [
      "fast_track_grass_and_python_files"
    ],
    "filters": [],
    "includes": {}
  }
}