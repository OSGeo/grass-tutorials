[
  {
    "objectID": "content/tutorials/get_started/grass_gis_in_google_colab.html",
    "href": "content/tutorials/get_started/grass_gis_in_google_colab.html",
    "title": "Get started with GRASS GIS in Google Colab",
    "section": "",
    "text": "What is Colab?\nPerhaps you have heard of Google Colaboratory or simply Colab. This is a hosted Jupyter Notebook service that requires no setup or configuration to use and provides free access to computing resources, including GPUs and TPUs. Colab is especially well suited to machine learning, data science, and education. Furthermore, it allows easy sharing of workflows which facilitates reproducibility.\nColab notebooks allow you to combine executable code and rich text in a single document, along with images, HTML, LaTeX and more. When you create your own Colab notebooks, they are stored in your Google Drive account. You can easily share your Colab notebooks with co-workers or friends, allowing them to comment on your notebooks or even edit them.\n\n\n\n\n\n\nNote\n\n\n\nSee Colab’s FAQ for more details: https://research.google.com/colaboratory/faq.html and follow the Google Colab blog in Medium at https://medium.com/google-colab.\n\n\n\n\nWhy GRASS GIS in Colab?\nSince Colab offers Jupyter notebooks in a Linux environment it is really easy to install or even compile GRASS GIS there. Also, because of the integration with Google Drive, it is a great resource to run our workflows in the cloud and export the results or keep our GRASS projects and code there. This clearly facilitates teaching workshops or courses since attendants do not need to install or download anything on their own machines.\nThere are a couple of things to consider when working with GRASS GIS within Colab though. Users will need to install GRASS GIS every time they start a new working session or notebook. Furthermore, whatever files users download within Colab will last only during the current session. If the runtime gets disconnected because of inactivity, downloaded data and outputs created within Colab, will be lost too. If users instead, mount their own Google drive, download data and create their GRASS projects there, those will be preserved even if the runtime is disconnected or the session closed.\n\n\nInstall GRASS GIS in Colab\nStart at https://colab.research.google.com/ and create a new notebook. Let’s first print system description to know where are we:\n\n!lsb_release -a\n\nAt the time of writing this tutorial, Colab has Linux Ubuntu 22.04.3 LTS. So we add the ppa:ubuntugis repository, update and install GRASS GIS. It might take a couple of minutes according to the resources available.\n\n!add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable\n!apt update\n!apt-get install -y grass-core grass-dev\nprint(\"INSTALLATION COMPLETE\")\n\nCheck that GRASS GIS is installed by asking which version is there.\n\n!grass --config version\n\nLet’s add the GRASS python packages to PATH to be able to import the grass.script and grass.jupyter libraries.\n\n# Import standard Python packages we need\nimport sys\nimport subprocess\n\n# Ask GRASS GIS where its Python packages are to be able to run it from the notebook\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n\n# Import the GRASS GIS packages\nimport grass.script as gs\nimport grass.jupyter as gj\n\n\n\nDownload sample data\nBy default we have access to the /content folder within Colab, and any data we download will be placed there. We can change that of course, it is just a Linux file system. In any case, we should bare in mind that whatever data we download within Colab, will disappear if the runtime gets disconected because of inactivity or once we close the Colab session.\nLet’s get the North Carolina sample dataset into Colab to show a data download workflow.\n\n!wget -c https://grass.osgeo.org/sampledata/north_carolina/nc_spm_08_grass7.zip -O nc.zip\n\nWe unzip the downloaded file in /content\n\n!unzip nc.zip\n\nand finally check it is indeed there:\n\nimport os\n\n# List files and directories\nos.listdir()\n\nYou should see nc_spm_08_grass7 sample dataset, which is a GRASS project.\n\n\nStart GRASS in Colab\nWe have GRASS GIS installed and a sample project to play around, so we are ready to start GRASS GIS within the North Carolina project.\n\n# Start GRASS in default project mapset\nsession = gj.init(\"nc_spm_08_grass7\")\n\nLet’s show the current GRASS GIS settings and check if the session actually works:\n\n# GRASS was started in default project mapset called PERMANENT\ngs.gisenv()\n\nJust as an example, we will list the raster maps and display one of them using the InteractiveMap class.\n\ngs.list_grouped(type=\"raster\")\n\n\nm = gj.InteractiveMap()\nm.add_raster(\"landclass96\")\nm.show()\n\n\n\nConnect Colab with Google Drive\nIf we do not want to loose our GRASS projects when closing the Colab notebook, we can connect Colab with our Google Drive and upload, download or create our projects there. To be able to do any of that, we need to mount our drive first (i.e., similar to what we do with external drives). We first import the drive library.\n\nfrom google.colab import drive \n\nThen, we define the mounting point. Running the cell below triggers a dialog to grant Colab access to our drive. It is possible to change accounts, too. Once that is complete, we will have access to everything we have in our GDrive folders and we can browse the content either with commands or from the left panel in the Colab notebook.\n\ndrive.mount(\"/content/drive\")\n\nWe can also mount our drive directly from the Colab interface as shown below:\n\nOnce the GDrive is mounted, we can either create a new project and start GRASS GIS there as shown above or start GRASS within an existing GRASS project in GDrive. Importantly, we can then process and analyse our data so that our data will remain in GDrive for the next time.\n\n\nCreate a new GRASS project in Google Drive\nTo create a new project we can use the create_project function from the grass.script library as shown in the GRASS and Python tutorial. Let’s, for example, create a project with the EPSG code option:\n\ngs.create_project(\"/content/drive/MyDrive/grassdata/latlong_wgs84\", epsg=\"4326\")\n\n\n\nStart GRASS GIS in an existing project\nEither if you just created the project and want to start GRASS GIS there or if you already have your GRASS projects in GDrive, you just need to start GRASS wherever the project is, as shown above, given that GRASS GIS has been installed in the Colab session and libraries imported.\nCool, ah?! Enjoy! \n\n\nThe development of this tutorial was funded by the US National Science Foundation (NSF), award 2303651."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_R.html",
    "href": "content/tutorials/get_started/fast_track_grass_and_R.html",
    "title": "Get started with GRASS & R: the rgrass package",
    "section": "",
    "text": "The rgrass package allows us to interact with GRASS tools (and data) serving as an interface between GRASS GIS and R. The rgrass package is developed and maintained by Roger Bivand and can be found at: https://github.com/rsbivand/rgrass/. In this fast track tutorial, we will learn how to use GRASS GIS from R."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_R.html#rgrass-main-functions",
    "href": "content/tutorials/get_started/fast_track_grass_and_R.html#rgrass-main-functions",
    "title": "Get started with GRASS & R: the rgrass package",
    "section": "rgrass main functions",
    "text": "rgrass main functions\nThe main functions within rgrass are the following:\n\ninitGRASS(): starts a GRASS session from R.\nexecGRASS(): executes GRASS commands from R.\ngmeta(): prints GRASS session metadata like database, project, mapset, computational region settings and CRS.\nread_VECT() and read_RAST(): read vector and raster maps from a GRASS project into R.\nwrite_VECT() and write_RAST(): write vector and raster objects from R into a GRASS project.\n\n\n\n\n\n\n\nNote\n\n\n\nFor further details on rgrass functionality, usage examples and data format coercion, see: https://rsbivand.github.io/rgrass/."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_R.html#basic-usage-choose-your-own-adventure",
    "href": "content/tutorials/get_started/fast_track_grass_and_R.html#basic-usage-choose-your-own-adventure",
    "title": "Get started with GRASS & R: the rgrass package",
    "section": "Basic usage: Choose your own adventure",
    "text": "Basic usage: Choose your own adventure\nIf you are a regular R user that needs to use GRASS GIS functionality because, well, you know it rocks, rgrass has your back. For example, maybe you struggle with large raster datasets in R or you need some specific tool, like watershed delineation for a large high resolution DEM. We will show here the way to use GRASS tools within your R workflows.\nOn the other hand, if you already use GRASS as your geospatial data processing engine, you most likely have your spatial data within GRASS projects. You might need however to do some statistical analysis, some modelling and prediction or create publication ready visualizations in R. In such cases, you can start a GRASS session in your project from R or RStudio.\nLet’s see the general basic steps and then dive into the details:\n\nMake sure GRASS GIS is installed.\nOpen R (or RStudio)\nLoad rgrass library with library(rgrass)\nStart a GRASS session with initGRASS()\nUse GRASS tools through execGRASS()\nUse read_VECT(), read_RAST(), write_VECT() and write_RAST() to read data from and write data into GRASS database.\n\n\n\n\n\n\n\nNote\n\n\n\nGRASS raster and vector maps are translated into terra’s package SpatRaster and SpatVector objects, respectively. These objects can then, within R, be easily coerced to other types of spatial objects such as simple features (sf), stars, etc.\nSee terra vignettes with further explanations and examples: https://rspatial.github.io/terra/.\n\n\n\nA. Use GRASS GIS tools within your R spatial workflows\nWe start R or Rstudio and load the rgrass library. It will tell us that GRASS is not running, but we know that already… and that’s about to change in a moment.\n\nlibrary(rgrass)\n\nIn case you need to include some of the cool GRASS tools within your R workflow, the initGRASS() function allows you to create temporary GRASS projects to use GRASS tools on R objects. This is equivalent to what QGIS does when you use GRASS tools via the QGIS Processing Toolbox.\nFirst, we will use initGRASS() to create a temporary GRASS project based on the extent, resolution and CRS of a raster or vector R object, likely the one we want to process or one that has the extent of our study area. Hence, we need to pass a reference spatial grid via the SG parameter. Then, we will write our R objects into the temporary GRASS project, run the desired processes, and export the outputs back to the R environment.\nLet’s start with getting some spatial data, e.g., a raster file, into R.\n\nlibrary(terra)\nf &lt;- system.file(\"ex/elev.tif\", package=\"terra\")\nr &lt;- rast(f)\nplot(r)\n\nNow, we will start GRASS GIS in a temporary folder. By specifying SG = r, the GRASS project is internally created with raster r’s object CRS (BTW, you can check that with crs(r)), extent and resolution. These latter define the GRASS computational region that will affect all raster processing, i.e., all new raster maps generated within GRASS GIS will have the same extent and resolution of the map provided. If you wish to change the computational region later on, you can use the g.region GRASS tool with execGRASS(\"g.region --h\").\nOptionally, we can specify which GRASS binary to use with gisBase. This might be useful in case we have several GRASS versions on our system. If not provided, initGRASS() will attempt to find it in default locations depending on your operating system.\n\n# Start GRASS GIS from R\ninitGRASS(home = tempdir(),\n          SG = r, \n          override = TRUE)\n\nNow, we can write our SpatRaster into the GRASS temporary project.\n\nwrite_RAST(r, \"terra_elev\")\n\nAlternatively, we can use GRASS importing tools to import common raster and vector formats. Data will be reprojected if needed.\n\nexecGRASS(\"r.import\", input=f, output=\"test\")\n\nLet’s check both raster maps (test and terra_elev) are indeed within the project and run the GRASS tool r.slope.aspect on one of them.\n\nexecGRASS(\"g.list\", type = \"raster\")\n\n\nexecGRASS(\"r.slope.aspect\", \n          elevation = \"terra_elev\", \n          slope = \"slope\",\n          aspect = \"aspect\")\n\n\nexecGRASS(\"g.list\", type = \"raster\")\n\nLet’s get slope and aspect maps into R\n\ngrass_maps &lt;- read_RAST(c(\"aspect\", \"slope\"))\ngrass_maps\n\nNow that the output maps are back into our R environment, we can plot them, do further analysis or write them into other raster formats, in which case we use terra::writeRaster() function.\n\nplot(grass_maps)\n\n\n\nwriteRaster(grass_maps, \"grass_maps.tif\", overwrite=TRUE)\n\nAlternatively, we can use GRASS GIS exporting tools like r.out.gdal and v.out.ogr, to directly save our outputs into common raster or vector formats, respectively.\n\nexecGRASS(\"r.out.gdal\", input=\"slope\", output=\"slope.tif\", format=\"GTiff\", flags=\"overwrite\")\n\n\n\nB. Use R tools within GRASS GIS workflows\nLet’s see an example for the case when we do our geospatial data processing within GRASS GIS and hence have all the spatial data organized within GRASS projects but we need to run some statistical analysis, modelling, prediction or visualization in R.\n\nlibrary(rgrass)\n\nWe start GRASS GIS from within R or RStudio using the initGRASS() function. Since we want to start GRASS GIS in a specific project and mapset, we need to specify them.\n\n# Start GRASS GIS from R\ninitGRASS(gisDbase = path.expand(\"~/grassdata/\"),\n          location = \"nc_basic_spm_grass7\",\n          mapset = \"PERMANENT\",\n          override = TRUE,\n          remove_GISRC = TRUE)\n\nWe can now list and read our GRASS raster and vector maps into R and do our statistical analysis, modelling and/or visualizations using other R packages. Here, we will demonstrate the use of all the main rgrass functions mentioned above.\nLet’s then list our GRASS raster and vector maps:\n\n# List GRASS raster maps\nexecGRASS(\"g.list\", type=\"raster\")\n\n\n# List GRASS vector maps\nexecGRASS(\"g.list\", type=\"vector\")\n\nThe resulting map lists could be saved in an R object that we can subset later in case we want to import several but not all raster maps, for example. Let’s see how to do that.\n\n# Save map list in an object\nrast_list &lt;- execGRASS(\"g.list\", type=\"raster\")\n\n# Retrieve only the map list from standard output\nrast_list &lt;- attributes(rast_list)$resOut\n\n# Import elevation and landuse\nto_import &lt;- c(\"elevation\", \"landuse\") # optionally, by position: rast_list[c(3,7)]\n\nmaplist &lt;- list()\nfor (i in to_import) {\n  maplist[[i]] &lt;- read_RAST(i)\n}\n\nmaplist\n\nRemember that raster objects will always be exported from GRASS GIS following the computational region settings. So, bear that in mind when reading into R which will hold them in memory. Vectors however will be exported in their full extent.\nLet’s load the terra library to quickly display our recently imported raster maps:\n\nlibrary(terra)\nplot(maplist$elevation)\n\nOptionally, we could stack our two SpatRaster objects together and plot them together:\n\nrstack &lt;- rast(maplist)\nplot(rstack)\n\nLet’s create a boxplot of elevation per land class.\n\nboxplot(rstack$elevation, rstack$landuse, maxcell=50000)\n\nLet’s import a vector map, too, and explore its attributes.\n\ncensus &lt;- read_VECT(\"census\")\nhead(census)\n\n\nsummary(census$TOTAL_POP)\n\n\nplot(census, \"P25_TO_34\", type=\"interval\", breaks=5, plg=list(x=\"topright\"))\n\nLet’s do some interactive visualization with mapview.\n\nlibrary(mapview)\nmapview(rstack$elevation) + census\n\nWe highly recommend you to check the tmap package to make really appealing and publication ready maps.\nTo exemplify the use of write_* functions, let’s do a simple operation with the landuse raster map. We will apply a custom function that makes NULL all values less than 4.\n\nresult &lt;- app(rstack$landuse, fun=function(x){ x[x &lt; 4] &lt;- NA; return(x)} )\nplot(result)\n\nTo use this new raster in GRASS GIS, for example as an input to a GRASS tool, we need to call write_RAST function:\n\nwrite_RAST(result, \"result_from_R\", overwrite = TRUE)\n\nThe new raster is now written as a GRASS raster and can be listed:\n\nexecGRASS(\"g.list\", parameters = list(type=\"raster\", pattern=\"result*\"))\n\nFinally, there is yet another way in which you can use GRASS and R together, and it involves calling R from the GRASS terminal. In this way, rgrass will read all GRASS session environmental variables, and you won’t need to use initGRASS(). It goes more or less like this:\n\nOpen GRASS GIS\nType R or rstudio & in the GRASS terminal\nLoad rgrass library with library(rgrass)\nUse read_VECT(), read_RAST() to read data from GRASS GIS into R\nDo your analysis or plotting in R\nWrite data (back) to GRASS database with write_VECT() and write_RAST()\nQuit R quit() and get back to GRASS terminal.\n\nStarting GRASS GIS...\n\n          __________  ___   __________    _______________\n         / ____/ __ \\/   | / ___/ ___/   / ____/  _/ ___/\n        / / __/ /_/ / /| | \\__ \\\\_  \\   / / __ / / \\__ \\\n       / /_/ / _, _/ ___ |___/ /__/ /  / /_/ // / ___/ /\n       \\____/_/ |_/_/  |_/____/____/   \\____/___//____/\n\nWelcome to GRASS GIS 8.4.0\nGRASS GIS homepage:                      https://grass.osgeo.org\nThis version running through:            Bash Shell (/bin/bash)\nHelp is available with the command:      g.manual -i\nSee the licence terms with:              g.version -c\nSee citation options with:               g.version -x\nIf required, restart the GUI with:       g.gui wxpython\nWhen ready to quit enter:                exit\n\nLaunching &lt;wxpython&gt; GUI in the background, please wait...\n[Raster MASK present]\nGRASS nc_basic_spm_grass7/PERMANENT:~ &gt; R\n\nR version 4.3.1 (2023-06-16) -- \"Beagle Scouts\"\nCopyright (C) 2023 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n&gt; library(rgrass)\nGRASS GIS interface loaded with GRASS version: GRASS 8.4.0 (2024)\nand location: nc_basic_spm_grass7\n&gt; \nEnjoy!"
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_R.html#references",
    "href": "content/tutorials/get_started/fast_track_grass_and_R.html#references",
    "title": "Get started with GRASS & R: the rgrass package",
    "section": "References",
    "text": "References\n\nBivand R (2024). rgrass: Interface Between ‘GRASS’ Geographical Information System and ‘R’. R package version 0.4-1, https://CRAN.R-project.org/package=rgrass.\n\n\n\nThe development of this tutorial was funded by the US National Science Foundation (NSF), award 2303651."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track.html",
    "href": "content/tutorials/get_started/fast_track.html",
    "title": "Get started with GRASS GIS",
    "section": "",
    "text": "In this notebook we will walk you through 5 simple steps to get you started with GRASS GIS."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track.html#step-1-install-the-software",
    "href": "content/tutorials/get_started/fast_track.html#step-1-install-the-software",
    "title": "Get started with GRASS GIS",
    "section": "Step 1: Install the software",
    "text": "Step 1: Install the software\nGRASS GIS is available on Windows, Linux and macOS. The binaries for Windows and macOS can be found at https://grass.osgeo.org/download/.\nWhich version to choose? We recommend the current release version, which at the time of writing this post is 8.4.\nIf you like testing the latest and greatest, you can go for the preview version which is updated daily and reflects the latest state of the source code.\nLet’s see an example of how to install GRASS GIS on Linux/Ubuntu:\nsudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable\nsudo apt-get update\nsudo apt-get install grass grass-gui grass-dev\nOn Windows, you can either select the standalone installer which will bring GRASS GIS bundeled with all its dependencies or use the OSGeo for Windows (OSGeo4W) meta-installer that will allow you to install many other geospatial software packages and will resolve all dependencies for you.\n\n\n\nInstall GRASS with OSGeo4W installer"
  },
  {
    "objectID": "content/tutorials/get_started/fast_track.html#step-2-open-grass-gis",
    "href": "content/tutorials/get_started/fast_track.html#step-2-open-grass-gis",
    "title": "Get started with GRASS GIS",
    "section": "Step 2: Open GRASS GIS",
    "text": "Step 2: Open GRASS GIS\nJust double click on the GRASS GIS  icon or type grass in a terminal. In any case, you’ll get both the terminal and the graphical user interface (GUI). You can use GRASS tools in either. It’s a matter of taste, task on hand and habit, too.\n\n\n\nGRASS Graphical User Interface and terminal\n\n\nGRASS GUI has a single window layout by default, but it is also possible to minimize and/or dock/undock the panels. On the right, you can find the data browser which allowa you to navigate through your projects and data, and the layers panel showing displayed layers. The panel in the middle is the map display. You can add additional ones if you need using . Finally, on the right there are multiple tabs where you can find a searchable tools’ tree similar to the Processing toolbox in QGIS, a console where you can type GRASS commands, the history of executed commands in case you want to re-run a task and a simple Python console where you can use the GRASS Python API.\n\n\n\n\n\n\nNote\n\n\n\nSee this example of the GRASS GIS single window GUI with multiple map displays:"
  },
  {
    "objectID": "content/tutorials/get_started/fast_track.html#step-3-create-a-project",
    "href": "content/tutorials/get_started/fast_track.html#step-3-create-a-project",
    "title": "Get started with GRASS GIS",
    "section": "Step 3: Create a project",
    "text": "Step 3: Create a project\nWhen you open GRASS GIS for the first time, a new directory is created in your home folder. This directory is called grassdata by default and stores all your GRASS projects. GRASS projects are simply folders storing your geospatial data with common coordinate reference system (CRS), ensuring consistency of your data. At the project level, data is further organized into subprojects called mapsets, which you can use to manage different subregions or analyses within a project. Each project contains a special mapset called PERMANENT, which is used to store source datasets for your analysis that can be easily accessed from other mapsets.\nWithin the grassdata directory you will see a sample project called world_latlong_wgs84 which contains the PERMANENT mapset, with a sample vector layer. While there are other sample data sets that you could download to play around with GRASS GIS and test it, you most likely have some data of your own that you want to process and analyse. Therefore, the third step is to create a new project and select its CRS by its name, EPSG code or take it from your input data. Let’s see a simple way to create a project in GRASS GUI. You can either click over “Create new project” in the info bar or use  icon.\n\n\n\nCreate a new GRASS project\n\n\nProjects can also be created from command line when starting GRASS. This is how we would create an UTM20S project, for example:\ngrass -c EPSG:32720 /home/username/grassdata/utm20s\nAlternatively, pass a georeferenced file which CRS will be used to create your project:\ngrass -c myraster.tif /home/username/grassdata/utm20s"
  },
  {
    "objectID": "content/tutorials/get_started/fast_track.html#step-4-import-your-data",
    "href": "content/tutorials/get_started/fast_track.html#step-4-import-your-data",
    "title": "Get started with GRASS GIS",
    "section": "Step 4: Import your data",
    "text": "Step 4: Import your data\nOnce you have created your GRASS project, you’ll notice it contains the PERMANENT mapset inside. You can import your data there or optionally you could create other mapsets to organize your work.\nWhy do we need to import data? GRASS has a native format for raster and vector data to facilitate robust and efficient analysis and manipulation of geospatial data. One advantage of this structure is that you can easily zip your mapsets or projects to share with your colleagues. And guess what? Not only data will be there but also the history of commands you have executed on them!\nSo, how do we import data? Let’s see an example for raster and vector data formats. For imports with optional re-projection, you can use  and  icons from the Data panel bar.\nIn the first case, we import 10m resolution bands from Copernicus Sentinel 2 scenes that can be found here. Note that we can import all files within a directory if we specify the extension of such files, jp2 in this case.\n\nIn another example, we import a GeoPackage with different CRS. Data will be automatically reprojected.\n\nMaps will be added to the layer tree and displayed automatically.\n\nWe could execute the same tasks from either the “Console” tab or the terminal. In that case, the commands to import a raster and a vector map would be:\nr.import input=myraster.tif output=myraster\nv.import input=myvector.gpkg output=myvector"
  },
  {
    "objectID": "content/tutorials/get_started/fast_track.html#step-5-set-the-computational-region",
    "href": "content/tutorials/get_started/fast_track.html#step-5-set-the-computational-region",
    "title": "Get started with GRASS GIS",
    "section": "Step 5: Set the computational region",
    "text": "Step 5: Set the computational region\nThe last important step, especially if you are working with raster data, is to set the computational region. This is the extent and resolution of your region of interest or study area, and it will affect all your raster processing, i.e., output rasters will have their extent and spatial resolution equal to the computational region. You can set the computational region to the extent of a vector map, to the extent and resolution of a raster map or manually introducing the north, south, east, and west coordinates.\nWhy do we need a computational region? When combining data with different resolution and extents, it helps keeping results consistent. Also, raster data might be large and running processes on them might take a while. Setting a smaller computational region allows you to test your algorithms and parameter values without the need to clip input maps, so once you are happy with the result, you can run the process for the whole raster extent.\n\nThe computational region can be changed interactively from the map display by selecting a region with your mouse, or using the g.region tool both from the GUI and command line.\n\nInteractive:\n\n\n\nUsing g.region from the contextual menu after right click on a layer:\n\n\n\nUsing g.region from the main menu in the GUI:\n\n\nNote how commands are formed when you select options in the GUI. If you use the  button, you can then paste these in a text file and set the basis of your protocol, which can then be generalized into a script or even your own GRASS tool.\n\n\nFrom the console tab or in the terminal:\n\ng.region -p raster=myraster\n\nGetting help\nThere are several sources you can get help from:\n\nManual pages online\ng.manual: eg., g.manual r.info\n--help or --h flag in command line, eg., r.info --h\nTutorials on the website\nJoin the GRASS community chat or subscribe to the mailing list.\n\nYou are ready! Enjoy! \n\n\nThe development of this tutorial was funded by the US National Science Foundation (NSF), award 2303651."
  },
  {
    "objectID": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html",
    "href": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html",
    "title": "Making plots with GRASS GIS",
    "section": "",
    "text": "In previous tutorials we saw examples of how to convert GRASS GIS raster and vector maps into Python and R objects to perform data analysis and visualizations. There are some GRASS GIS tools, mostly based in the well known matplotlib Python library, that allow us to create plots for data visualization without the need to explicitly convert GRASS data. Here are these plotting tools for raster, vector and time series data within GRASS GIS:\nIn this tutorial, we’ll demonstrate their use with maps from the North Carolina full dataset. We’ll also use a special mapset containing MODIS LST data products to exemplify tools’ usage with time series data. While these tools can be invoked from the GUI menu or Tools tab, we will show how the GRASS commands look like so you can run them from the terminal or the Console tab of the GUI. We also show the command wrapping for Python scripts using the grass.script package. You can test them in the Python tab. The use of commands facilitates reproducibility and quick testing of small changes and tweaks."
  },
  {
    "objectID": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html#raster-plotting-tools",
    "href": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html#raster-plotting-tools",
    "title": "Making plots with GRASS GIS",
    "section": "Raster plotting tools",
    "text": "Raster plotting tools\n\nr.boxplot\nr.boxplot is a GRASS GIS addon that allows us to make boxplots with our GRASS raster maps. It also allows to use a zonal map like a land cover classification to draw boxplots of a certain variable per classes, i.e., land cover classes. The tool then contemplates some nice features like the possibility to plot per class boxplots of the same color that the class is assigned in the zonal map or create a point vector map with the locations of the outliers, among other tweaks. Let’s see an example using a zonal map, plotting outliers and coloring boxes with the colors of the zonal map classes:\n\nBashPython\n\n\n\ng.extension extension=r.boxplot\nr.boxplot -oc input=elevation zones=landclass96 output=r.boxplot.png\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"r.boxplot\")\ngs.run_command(\"r.boxplot\", \n               input=\"elevation\", \n               zones=\"landclass96\", \n               raster_statistics=\"median,IQR\", \n               output=\"r.boxplot.png\",\n               flags=\"oc\")\n\n\n\n\n\n\n\nr.series.boxplot\nr.series.boxplot draws boxplots of a series of input raster maps that might represent different times, spectral bands in satellite imagery or other kind of variation. If users are interested in e.g., ploting the spectral signature of different land cover classes, they can alternatively set masks and recreate the boxplot series. Let’s see an example for developed and forested classes.\n\nBashPython\n\n\n\n# install the extension\ng.extension extension=r.series.boxplot\n# add landsat mapset to the list of accessible mapsets\ng.mapsets mapset=landsat operation=add\n# list of maps and labels\nbands=`g.list type=raster pattern=\"lsat7_2000*\" exclude=\"*6*,*8*\" sep=comma`\nlabels=\"band1,band2,band3,band4,band5,band7\"\n\nr.mask raster=landclass96 maskcats=1\nr.series.boxplot map=$bands bxcolor=grey text_labels=$labels output=r.series.boxplot_developed.png\n\nr.mask -r \n\nr.mask raster=landclass96 maskcats=5\nr.series.boxplot map=$bands bxcolor=grey \\\n  text_labels=$labels output=r.series.boxplot_forest.png\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"r.series.boxplot\")\n\ngs.run_command(\"g.mapsets\", mapset=\"landsat\", operation=\"add\")\n\nbands = gs.list_grouped(type=\"raster\", pattern=\"lsat7_2000*\", exclude=\"*6*,*8*\")[\"landsat\"]\nlabels = [\"band1\", \"band2\", \"band3\", \"band4\", \"band5\", \"band7\"]\n\ngs.run_command(\"r.mask\", raster=\"landclass96\", maskcats=\"1\")\ngs.run_command(\"r.series.boxplot\", \n              map=bands, \n              bxcolor=\"grey\", \n              text_labels=labels, \n              output=\"r.series.boxplot_developed.png\")\n\ngs.run_command(\"r.mask\", flags=\"r\")\n\ngs.run_command(\"r.mask\", raster=\"landclass96\", maskcats=\"5\")\n\ngs.run_command(\"r.series.boxplot\", \n              map=bands, \n              bxcolor=\"grey\", \n              text_labels=labels, \n              output=\"r.series.boxplot_forested.png\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nClass developed\n\n\n\n\n\n\n\nClass forest"
  },
  {
    "objectID": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html#vector-plotting-tools",
    "href": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html#vector-plotting-tools",
    "title": "Making plots with GRASS GIS",
    "section": "Vector plotting tools",
    "text": "Vector plotting tools\n\nv.boxplot\nv.boxplot draws the boxplot of values in a vector map attribute column. It also provides an option to group by categories in a second attribute column.\n\nBashPython\n\n\n\ng.extension extension=v.histogram\n\nv.boxplot -o -r map=bridges column=WIDTH group_by=YEAR_BUILT where=\"YEAR_BUILT &lt; '1920'\" order=ascending plot_output=boxplot_bridges_width_per_year.png\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"v.histogram\")\n\ngs.run_command(\"v.boxplot\",\n              map=\"bridges\", \n              column=\"WIDTH\", \n              group_by=\"YEAR_BUILT\", \n              where=\"YEAR_BUILT &lt; '1920'\", \n              order=\"ascending\", \n              plot_output=\"boxplot_bridges_width_per_year.png\", \n              flags=\"or\")\n\n\n\n\n\n\n\nv.scatterplot\nv.scatterplot creates a scatterplot with the values of two attribute columns from a vector map. It provides many arguments to control different plot features and it exposes some nice matplotlib functionality to do bining, add trend lines and confidence ellipses. While there’s r.scatterplot for raster data, it does not create a plot but a vector map. Users can, however, sample raster maps with a vector and then create scatterplots from the sampled data.\n\nBashPython\n\n\n\ng.extension extension=v.scatterplot\n\nv.scatterplot map=bridges x=YEAR_BUILT y=WIDTH trendline=polynomial degree=1 line_color=red type=density bins=10,10 file_name=scatterplot_bridges_width_vs_year.png\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"v.scatterplot\")\n\ngs.run_command(\"v.scatterplot\", \n              map=\"bridges\", \n              x=\"YEAR_BUILT\", \n              y=\"WIDTH\", \n              trendline=\"polynomial\", \n              degree=1, \n              line_color=\"red\", \n              type=\"density\", \n              bins=\"10,10\", \n              file_name=\"scatterplot_bridges_width_vs_year.png\")\n\n\n\n\n\n\n\nv.histogram\nv.histogram draws a histogram of the values in a vector map attribute column. The tool provides basic options to select values according to a condition and set the number of bins.\n\nBashPython\n\n\n\ng.extension extension=v.histogram\n\nv.histogram map=bridges column=WIDTH where=\"YEAR_BUILT &lt; '1940'\" plot_output=histogram_bridges_width.png\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"v.histogram\")\n\ngs.run_command(\"v.histogram\", \n              map=\"bridges\", \n              column=\"WIDTH\", \n              where=\"YEAR_BUILT &lt; '1940'\", \n              plot_output=\"histogram_bridges_width.png\")"
  },
  {
    "objectID": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html#time-series-plotting-tools",
    "href": "content/tutorials/good_looking_plots/good_looking_plots_in_grass.html#time-series-plotting-tools",
    "title": "Making plots with GRASS GIS",
    "section": "Time series plotting tools",
    "text": "Time series plotting tools\n\ng.gui.tplot\ng.gui.tplot is part of GRASS GIS core distribution and it allows to plot the values of raster and vector time series. Users can pass coordinate pairs for the case of raster time series and ids plus attribute column in the case of vector time series. The module also supports to display the trend line based on a linear regression and the R-squared value, visualize pop-up annotations, export the time series values to a text file, among other. Let’s see an example for the MODIS LSD DAY monthly raster time series.\n\nBashPython\n\n\n\ng.region -p raster=MOD11B3.A2015001.h11v05.single_LST_Day_6km\ng.gui.tplot -l strds=LST_Day_monthly coordinates=413831,196000 xlabel=\"Time\" ylabel=\"LST (K*50)\" output=LST_plot.png size=1000,800\n\n\n\n\ngs.read_command(\"g.region\", \n                raster=\"MOD11B3.A2015001.h11v05.single_LST_Day_6km\")\n                \ngs.run_command(\"g.gui.tplot\", \n              strds=\"LST_Day_monthly\", \n              coordinates=\"413831,196000\", \n              xlabel=\"Time\", \n              ylabel=\"LST (K*50)\", \n              output=\"LST_plot.png\", \n              size=\"1000,800\", \n              flags=\"l\")\n\n\n\n\n\n\n\nt.rast.boxplot\nt.rast.boxplot draws boxplots from raster maps in a space-time raster dataset, hence the x axis is determined by the STRDS temporal granularity, i.e., day, week, month, etc. Let’s see an example for plotting monthly LST within the state of North Carolina.\n\nBashPython\n\n\n\ng.extension extension=t.rast.boxplot\ng.region -p vector=boundary_county align=MOD11B3.A2015001.h11v05.single_LST_Day_6km\nr.mask vector=boundary_county\nt.rast.boxplot -o input=LST_Day_monthly dpi=300 rotate_labels=90 font_size=11 date_format=\"%Y-%m\" bx_width=0.7 bx_color=195:194:194:255 flier_color=77:77:77:255\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"t.rast.boxplot\")\n\ngs.read_command(\"g.region\", vector=\"boundary_county\", align=\"MOD11B3.A2015001.h11v05.single_LST_Day_6km\")\n\ngs.run_command(\"r.mask\", vector=\"boundary_county\")\n\ngs.run_command(\"t.rast.boxplot\", \n              input=\"LST_Day_monthly\", \n              dpi=\"300\", \n              rotate_labels=90, \n              font_size=11, \n              date_format=\"%Y-%m\", \n              bx_width=0.7, \n              bx_color=\"195:194:194:255\", \n              flier_color=\"77:77:77:255\", \n              flags=\"o\")\n\n\n\n\n\nIf users would like to compare boxplot time series representing different areas, they could alternatively set masks for their areas of interest and then create the respective boxplot time series.\n\nBashPython\n\n\n\nr.mask vector=geology where=\"GEO_NAME LIKE '%Zat%'\"\nt.rast.boxplot -o input=LST_Day_monthly dpi=300 rotate_labels=90 font_size=11 date_format=\"%Y-%m\" bx_width=0.7 bx_color=195:194:194:255 flier_color=77:77:77:255\n\nr.mask -r\n\nr.mask vector=geology where=\"GEO_NAME LIKE '%Qp%'\"\nt.rast.boxplot -o input=LST_Day_monthly dpi=300 rotate_labels=90 font_size=11 date_format=\"%Y-%m\" bx_width=0.7 bx_color=195:194:194:255 flier_color=77:77:77:255\n\n\n\n\ngs.run_command(\"r.mask\", vector=\"geology\", where=\"GEO_NAME LIKE '%Zat%'\")\n\ngs.run_command(\"t.rast.boxplot\", \n              input=\"LST_Day_monthly\", \n              dpi=300, \n              rotate_labels=90, \n              font_size=11, \n              date_format=\"%Y-%m\", \n              bx_width=0.7, \n              bx_color=\"195:194:194:255\", \n              flier_color=\"77:77:77:255\", \n              flags=\"o\")\n\ngs.run_command(\"r.mask\", flags=\"r\")\n\ngs.run_command(\"r.mask\", vector=\"geology\", where=\"GEO_NAME LIKE '%Qp%'\")\n\ngs.run_command(\"t.rast.boxplot\", \n              input=\"LST_Day_monthly\", \n              dpi=300, \n              rotate_labels=90, \n              font_size=11, \n              date_format=\"%Y-%m\", \n              bx_width=0.7, \n              bx_color=\"195:194:194:255\", \n              flier_color=\"77:77:77:255\", \n              flags=\"o\")\n\n\n\n\n\n\nt.rast.line\nt.rast.line draws line plots from raster maps in a space-time raster dataset and also allows to pass a zonal map to compare average temporal changes of different areas of interest in the same plot.\n\nBashPython\n\n\n\ng.extension extension=t.rast.line\nt.rast.line input=LST_Day_monthly zones=boundary_county_500m y_label=\"LST (K*50)\" date_format=%Y-%m\n\n\n\n\ngs.run_command(\"g.extension\", extension=\"t.rast.line\")\n\ngs.run_command(\"t.rast.line\", \n              input=\"LST_Day_monthly\", \n              zones=\"boundary_county_500m\", \n              y_label=\"LST (K*50)\", \n              date_format=\"%Y-%m\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn GRASS GIS",
    "section": "",
    "text": "Get started with GRASS in Jupyter Notebooks on Windows\n\n\n\nPython\n\n\nWindows\n\n\nbeginner\n\n\n\n\n\n\n\nCaitlin Haedrich\n\n\nJun 15, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nMaking plots with GRASS GIS\n\n\n\nstatistics\n\n\nmatplotlib\n\n\nbeginner\n\n\n\n\n\n\n\nVeronica Andreo\n\n\nApr 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nGet started with GRASS GIS in Google Colab\n\n\n\nPython\n\n\nGoogle Colab\n\n\nbeginner\n\n\n\n\n\n\n\nVeronica Andreo\n\n\nApr 12, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nQuick comparison: R and Python GRASS interfaces\n\n\n\nPython\n\n\nR\n\n\nintermediate\n\n\n\n\n\n\n\nVeronica Andreo\n\n\nApr 1, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nGet started with GRASS & R: the rgrass package\n\n\n\nR\n\n\nrgrass\n\n\nintermediate\n\n\n\n\n\n\n\nVeronica Andreo\n\n\nMar 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nGet started with GRASS & Python in Jupyter Notebooks\n\n\n\nPython\n\n\nbeginner\n\n\n\n\n\n\n\nVeronica Andreo\n\n\nMar 25, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nGet started with GRASS GIS\n\n\n\nbeginner\n\n\nGUI\n\n\n\n\n\n\n\nVeronica Andreo\n\n\nMar 19, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html",
    "href": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html",
    "title": "Quick comparison: R and Python GRASS interfaces",
    "section": "",
    "text": "In this short tutorial we will highlight the similarities of R and Python GRASS interfaces in order to streamline the use of GRASS GIS within R and Python communities. As you may know, there’s an R package called rgrass that provides basic functionality to read and write data from and into GRASS database as well as to execute GRASS tools in either existing or temporary GRASS projects. The GRASS Python API, on the other hand, is composed of various packages that provide classes and functions for low and high level tasks, including those that can be executed with rgrass.\nThere are some parallelisms between the rgrass and grass.script/grass.jupyter packages, i.e., R and Python interfaces to GRASS GIS. Let’s review them and go through some examples."
  },
  {
    "objectID": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html#comparison-examples",
    "href": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html#comparison-examples",
    "title": "Quick comparison: R and Python GRASS interfaces",
    "section": "Comparison examples",
    "text": "Comparison examples\nLet’s see how usage examples would look like.\n\nLoad the library: We need to load the libraries that allow us to interface with GRASS GIS functionality and (optionally) data. For the Python case, we first need to add the GRASS python package path to our system’s path.\n\n\nRPython\n\n\n\nlibrary(rgrass)\n\n\n\n\nimport sys\nimport subprocess\n\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\nimport grass.script as gs\nimport grass.jupyter as gj\n\n\n\n\n\nStart a GRASS session: Once we loaded or imported the packages, we start a GRASS session. We need to pass the path to a temporary or existing GRASS project. In the case of R, initGRASS will automatically look for GRASS binaries, alternatively we can specify the path to the binaries ourselves. In the case of Python, it is worth noting that while grass.script and grass.jupyter init functions take the same arguments, gj.init also sets other environmental variables to streamline work within Jupyter Notebooks, e.g., overwrite is set to true so cells can be executed multiple times.\n\n\nRPython\n\n\n\nsession &lt;- initGRASS(gisBase = \"/usr/lib/grass84\", # where grass binaries live, `grass --config path`\n                     gisDbase = \"/home/user/grassdata\", # path to grass database or folder where your project lives\n                     location = \"nc_basic_spm_grass7\", # existing project name\n                     mapset = \"PERMANENT\" # mapset name\n                     )\n\n\n\n\n# With grass.script for scripts\nsession = gs.setup.init(path=\"/home/user/grassdata\",\n              location=\"nc_basic_spm_grass7\",\n              mapset=\"PERMANENT\")\n# Optionally, the path to a mapset\nsession = gs.setup.init(\"/home/user/grassdata/nc_basic_spm_grass7/PERMANENT\")\n\n# With grass.jupyter for notebooks\nsession = gj.init(path=\"/home/user/grassdata\",\n                  location=\"nc_basic_spm_grass7\",\n                  mapset=\"PERMANENT\")\n# Optionally, the path to a mapset\nsession = gj.init(\"~/grassdata/nc_basic_spm_grass7/PERMANENT\")\n\n\n\n\n\nExecute GRASS commands: Both interfaces work pretty similarly, the first argument is always the GRASS tool name and then we pass the parameters and flags. While in R we basically use execGRASS() for all GRASS commands, in the Python API, we have different wrappers to execute GRASS commands depending on the nature of their output.\n\n\nRPython\n\n\n\n# Map output\nexecGRASS(\"r.slope.aspect\",\n          elevation = \"elevation\",\n          slope = \"slope\",\n          aspect = \"aspect\")\n\n# Text output\nexecGRASS(\"g.region\",\n          raster = \"elevation\",\n          flags = \"p\")\n\n\n\n\n# Map output\ngs.run_command(\"r.slope.aspect\",\n               elevation=\"elevation\",\n               slope=\"slope\",\n               aspect=\"aspect\")\n# Text output\nprint(gs.read_command(\"g.region\",\n                      raster=\"elevation\",\n                      flags=\"p\"))\n# Text output - dictionary\nregion = gs.parse_command(\"g.region\",\n                          raster=\"elevation\",\n                          flags=\"g\")\nregion\n\n\n\n\n\nRead raster and vector data into other R or Python formats: rgrass functions read_RAST() and read_VECT() convert GRASS raster and vector maps into terra’s SpatRaster and SpatVector objects within R. In the case of Python, GRASS raster maps that can be converted into numpy arrays through gs.array.array(). Vector attribute data can be converted into Pandas data frames in various ways.\n\n\nRPython\n\n\n\n# Raster\nelevr &lt;- read_RAST(\"elevation\")\n\n# Vector\nschoolsr &lt;- read_VECT(\"schools\")\n\n\n\n\n# Raster into numpy array\nelev = gs.array.array(\"elevation\")\n\n# Vector attributes\nimport pandas as pd\nschools = gs.parse_command(\"v.db.select\", map=\"schools\", format=\"json\")\npd.DataFrame(schools[\"records\"])\n\n# Vector geometry and attributes to GeoJSON\ngs.run_command(\"v.out.ogr\", input=\"schools\", output=\"schools.geojson\", format=\"GeoJSON\")\n\n\n\n\n\nWrite R or Python objects into GRASS raster and vector maps: R terra’s SpatRaster and SpatVector objects can be written (back) into GRASS format with write_RAST() and write_VECT() functions. Within the Python environment, numpy arrays can also be written (back) into GRASS raster maps with the write() method.\n\n\nRPython\n\n\n\n# Raster\nwrite_RAST(elevr, \"elevation_r\")\n\n# Vector\nwrite_VECT(schoolsr, \"schools_r\")\n\n\n\n\n# Raster\nelev.write(mapname=\"elev_np\", overwrite=True)\n\n# GeoJSON into GRASS vector\ngs.run_command(\"v.in.ogr\", input=\"schools.geojson\", output=\"schools2\")\n\n\n\n\n\nClose GRASS GIS session: In general, just closing R or Rstudio, as well as shutting down Jupyter notebook, will clean up and close the GRASS session properly. Sometimes, however, especially if the user changed mapset within the workflow, it is better to clean up explicitly before closing.\n\n\nRPython\n\n\n\nunlink_.gislock()\n\n\n\n\nsession.finish()"
  },
  {
    "objectID": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html#final-remarks",
    "href": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html#final-remarks",
    "title": "Quick comparison: R and Python GRASS interfaces",
    "section": "Final remarks",
    "text": "Final remarks\nThe examples and comparisons presented here are intended to facilitate the combination of tools and languages as well as the exchange of data and format conversions. We hope that’s useful as a starting point for the implementation of different use cases and workflows that suit the needs of users. See R and Python tutorials for more examples:\n\nGRASS and Python tutorial for beginners\nGRASS and R tutorial for beginners"
  },
  {
    "objectID": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html#references",
    "href": "content/tutorials/r_python_interfaces_comparison/quick_comparison_r_vs_python_grass_interfaces.html#references",
    "title": "Quick comparison: R and Python GRASS interfaces",
    "section": "References",
    "text": "References\n\nGRASS Python API docs\nrgrass docs\n\n\n\nThe development of this tutorial was funded by the US National Science Foundation (NSF), award 2303651."
  },
  {
    "objectID": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html",
    "href": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html",
    "title": "Get started with GRASS in Jupyter Notebooks on Windows",
    "section": "",
    "text": "The development of the Python package grass.jupyter, has streamlined the use of GRASS GIS is Jupyter notebooks. In this tutorial we will demonstrate the recommended way of running GRASS GIS in Jupyter Notebooks for Windows users."
  },
  {
    "objectID": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#set-up",
    "href": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#set-up",
    "title": "Get started with GRASS in Jupyter Notebooks on Windows",
    "section": "Set Up",
    "text": "Set Up\nOn Windows, we’ll use the OSGeo4W package manager to setup and update GRASS GIS, Jupyterlab and other dependencies. Follow the directions below to setup Jupyter and GRASS in Windows.\n\n1. Download the OSGeo4W Network Installer\nDownload the OSGeo4W network install from here. Open it and select “Advanced Install”.\n\n\n2. Install GRASS GIS, Jupyterlab and grass.jupyter dependencies\nFollow the prompts until you get to the “Select Packages” window (the defaults are fine for most situations). Use the Search bar to find and select the following packages for install (switching from “Skip” to the version number):\n\ngrass\npython3-jupyterlab\npython3-ipywidgets\n\n\n\n\nInstall GRASS with OSGeo4W installer\n\n\n\n\n3. Go make a cup of tea\nIt may take a minute to install… Click “Finish” and exit when it finishes.\n\n\n4. Open the OSGeo4W Shell and install folium\nLaunch the OSGeo4W Shell and install folium with:\npip install folium\n\n\n5. Launch Jupyter Lab\nWe’re ready to launch jupyterlab now:\njupyter lab\nThis should launch Jupyter lab in your default web browser. Use the left side panel to navigate to the notebook you wish to run and you’re ready to go!\n\n\n6. Launching Jupyter Lab in the Future\nTo launch Jupyter Lab in the future:\n\nOpen the OSGeo4W Shell\nLaunch jupyter lab with jupyter lab"
  },
  {
    "objectID": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#start-grass-within-jupyter",
    "href": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#start-grass-within-jupyter",
    "title": "Get started with GRASS in Jupyter Notebooks on Windows",
    "section": "Start GRASS within Jupyter",
    "text": "Start GRASS within Jupyter\nNow, we’re ready to code! Let’s import the GRASS GIS Python packages and launch GRASS GIS. If you want to run this tutorial, please download and unzip the North Carolina sample dataset.\n\n# Import standard python packages\nimport sys\nimport subprocess\n\n# Ask GRASS GIS where its Python packages are and add them to the path\ngrass_call = \"grass83\"\nsys.path.append(\n    subprocess.check_output([grass_call, \"--config\", \"python_path\"], text=True, shell=True).strip()\n)\n\n# Import the GRASS GIS python packages we need\nimport grass.script as gs\nimport grass.jupyter as gj\n\n# Launch a GRASS GIS session.\ngj.init(\"path/to/nc_spm_08_grass/user1\");"
  },
  {
    "objectID": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#using-grass",
    "href": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#using-grass",
    "title": "Get started with GRASS in Jupyter Notebooks on Windows",
    "section": "Using GRASS",
    "text": "Using GRASS\nNow that we have GRASS GIS running in our notebook, let’s try some basic commands.\nIn this section, we will set the color table to the elevation raster map from the GRASS GIS sample project we downloaded and then display it.\n\n# Set the computational region to the study area\ngs.parse_command(\"g.region\", \n                raster=\"elevation\", \n                flags='pg')\n\n# Set colors for elevation raster\ngs.run_command(\"r.colors\", \n              map=\"elevation\", \n              color=\"elevation\")\n\n\n# Create Map instance\nimg = gj.Map()\n# Add a raster\nimg.d_rast(map=\"elevation\")\n# Add legend\nimg.d_legend(raster=\"elevation\", at=(55, 95, 80, 84), flags=\"b\")\n# Display map\nimg.show()\n\nNow, we’re up and running! Have a look at other tutorials for inspiration on the avenues you can follow with GRASS tools combined with other Python packages."
  },
  {
    "objectID": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#troubleshooting",
    "href": "content/tutorials/get_started/JupyterOnWindows_OSGeo4W_Tutorial.html#troubleshooting",
    "title": "Get started with GRASS in Jupyter Notebooks on Windows",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nSomething not working? Here are some common stumbling blocks…\n\nFileNotFoundError\n\n\nFileNotFoundError: [WinError 2] The system cannot find the file specified\n\nCheck the shell parameter in the subprocess.check_output(). On Windows, this should be shell=True. On Mac and Linux operating systems, this should be shell=False.\n\nCalledProcessError\n\n\nCalledProcessError: Command '['grass83', '--config', 'python_path']' returned non-zero exit status 1.\n\nCheck which version of GRASS GIS you have installed. On Windows, the grass_call should be grass followed by the first two digits of the version you have installed (for example, GRASS GIS 8.4 would be called with grass84). On Mac and Linux, it should be just grass.\n\nErrors from gj.init()\n\nThis command takes several different configurations of the GRASS GIS project and mapset location on your system. All the following are examples that work:\ngj.init(\"path/to/grassdata\", \"project_name\", \"mapset_name\")\ngj.init(\"path/to/project_name/mapset_name\")\ngj.init(\"../project_name/mapset_name\")\nAlso pay attention to the slash direction. Windows uses \\ in it’s file paths but the \\ character in strings is also for escaping characters (for example, putting \\n in a string will print a new line). Therefore, you’ll need to either switch to forward slashes (/) or put double back-slashes (\\\\)."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_python.html",
    "href": "content/tutorials/get_started/fast_track_grass_and_python.html",
    "title": "Get started with GRASS & Python in Jupyter Notebooks",
    "section": "",
    "text": "Python, a widely used general-purpose, high-level programming language provides a powerful scripting interface for geospatial data processing. Being easy-to-use yet powerful, it enables users to efficiently exploit the capabilities of the GRASS GIS software. Python scripts for GRASS GIS can be written at high level (GRASS GIS tools) as well as at low level (GRASS GIS libraries) through dedicated interfaces. Indeed, GRASS GIS is distributed with a set of python packages to provide functionalities at different levels.\nIn this tutorial, we will focus on two packages: grass.script and grass.jupyter, which provide Python interface to launch GRASS GIS tools in scripts and offer classes and setup functions for running GRASS GIS in Jupyter Notebooks, respectively. We will show two different use cases:\nLet’s first go through the main functions of GRASS GIS Python packages."
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_python.html#lets-get-started",
    "href": "content/tutorials/get_started/fast_track_grass_and_python.html#lets-get-started",
    "title": "Get started with GRASS & Python in Jupyter Notebooks",
    "section": "Let’s get started!",
    "text": "Let’s get started!\n\nSetup\nThis tutorial can be run locally. You need to have GRASS GIS 8.4+ and Jupyter installed. For part A, please download these Sentinel 2 scenes and move the unzipped download into the directory where you are running this tutorial. For part B, we asume that you have downloaded the North Carolina sample dataset, i.e., there’s an existing GRASS project. Be sure you also have the following Python libraries installed in your environment: folium or ipyleaflet, numpy, seaborn, matplotlib, pandas.\nThe first thing we need to do is to import GRASS GIS python packages. In order to do so, we need to add GRASS GIS python package to PATH. Let’s see how we do that.\n\n# import standard Python packages\nimport os\nimport sys\nimport subprocess\nfrom pathlib import Path\n\n\n# check where GRASS GIS python packages are and add them to PATH\nsys.path.append(\n    subprocess.check_output([\"grass\", \"--config\", \"python_path\"], text=True).strip()\n)\n\n\n# import GRASS GIS python packages\nimport grass.script as gs\nimport grass.jupyter as gj\n\n\n\n\n\n\n\nNote\n\n\n\nWe recommend Windows users to review how to run GRASS GIS in Jupyter Notebooks on Windows.\n\n\n\n\nA. Use GRASS GIS tools within your Python spatial workflows\nNow, let’s assume you have some raster data you want to process with GRASS GIS tools, eg. Sentinel 2 satellite data, to obtain texture indices. The first thing you’ll need to do is to create a GRASS GIS project to import your data. As we saw already in a previous fast track tutorial, GRASS projects are folders where we store spatial data with the same spatial reference. These projects can be placed wherever you want, including a temporary directory if you are mostly interested in the outputs only.\nSo, let’s create a project in a temporary directory to import, i.e. read, our data with GRASS GIS. The gs.create_project() function allows us to create a GRASS project passing different information. For example, we can use the EPSG code of the data CRS or directly pass a georeferenced file.\n\n# Create a temporary folder where to place our GRASS project\nimport tempfile\ntempdir = tempfile.TemporaryDirectory()\n\n\n# Create a project in the temporary directory\ngs.create_project(path=tempdir.name,\n                  name=\"nc_sentinel\",\n                  epsg=\"32617\")\n\nAlternatively, use a georeferenced file to read the spatial reference information from:\n\n# gs.create_project(path=tempdir.name, name=\"nc_sentinel\", filename=\"path/to/georef/file\", overwrite=True)\n\nNow that we created a project, let’s start a GRASS GIS session there.\n\n# Start GRASS in the recently created project\nsession = gj.init(Path(tempdir.name, \"nc_sentinel\"))\n\nWe are now ready to import data into the recently created project. Let’s use a for loop to import all 10 m resolution bands. These are level 2A surface reflectance data for blue, green, red and near infrared Sentinel 2 bands.\n\nimport shutil\n\nshutil.unpack_archive(\"./nc_sentinel_utm17n/S2A_MSIL2A_20220304T160151_N0400_R097_T17SQV_20220304T215812.zip\", \"./nc_sentinel_utm17n\")\nfiles = sorted(Path('./nc_sentinel_utm17n/S2A_MSIL2A_20220304T160151_N0400_R097_T17SQV_20220304T215812.SAFE/GRANULE/L2A_T17SQV_A034986_20220304T160221/IMG_DATA/R10m').glob('*B*.jp2'))\nfiles\n\n\nfor file in files:\n    name = str(file)[-11:-4]\n    print(\"importing \" + name)\n    gs.run_command(\"r.import\", input=file, output=name)\n\nLet’s check the files we just imported are there:\n\ngs.list_grouped(type=\"raster\")[\"PERMANENT\"]\n\nLet’s have a quick look at one of the imported bands. We can use the InteractiveMap class from the grass.jupyter package to visualize it.\n\nm = gj.InteractiveMap()\nm.add_raster(\"B08_10m\")\nm.show()\n\nNext step is to do some processing or analysis with the imported data. Since we’ll be creating new raster maps, we first need to set our computational region to the extent and resolution of one of our imported bands.\n\n# Set computational region\ngs.run_command(\"g.region\", raster=\"B08_10m\", flags=\"p\")\n\n\nm = gj.InteractiveMap(tiles=\"OpenStreetMap\")\nm.add_raster(\"B08_10m\")\nm.show()\n\nIt is common to estimate texture measures over panchromatic bands. Since we do not have one in Sentinel 2 data, we’ll create a synthetic one by averaging blue, green and red bands.\n\n# Create synthetic pan band\ngs.mapcalc(\"pan = (B02_10m + B03_10m + B04_10m) / 3\")\n\nNow that we have the synthetic pan band, let’s estimate some texture measures with the r.texture tool.\n\ngs.run_command(\"r.texture\",\n              input=\"pan\",\n              output=\"pan\",\n              size=5,\n              method=\"contrast,corr\")\n\n\ngs.list_grouped(type=\"raster\", pattern=\"pan*\")[\"PERMANENT\"]\n\n\nt = gj.InteractiveMap(tiles=\"OpenStreetMap\")\nt.add_raster(\"pan_Contr\")\nt.add_raster(\"pan_Corr\")\nt.show()\n\nFinally, we can export our texture maps out of GRASS GIS and use them somewhere else or load them into a webGIS.\n\ntexture_maps = gs.list_grouped(type=\"raster\", pattern=\"pan_*\")[\"PERMANENT\"]\ntexture_maps\n\n\nfor texture in texture_maps:\n    gs.run_command(\"r.out.gdal\", input=texture, output=f\"{texture}.tif\", format=\"GTiff\")\n\nThis use case follows the Extract-Transform-Load (ETL) process common in production systems. Indeed, this approach allows to include GRASS tools into such workflows. These type of tasks could be automatized in scripts to be run without even starting GRASS GIS using the --exec tool… but that’s material for a different tutorial :)\n\n\nB. Use Python tools within GRASS GIS workflows\nThis case is more relevant for GRASS users who want to combine GRASS GIS with other Python tools for their data processing and analysis workflows.\nSeveral GRASS users store most or all of their projects in a single folder, which has traditionally been called grassdata. When this is the case, to start GRASS GIS in an existing project, we also need to provide the path to such a folder.\n\n# Start GRASS\nsession = gj.init(\"~/grassdata/nc_basic_spm_grass7/PERMANENT\")\n# alternatively\n# session = gj.init(\"~/grassdata/nc_basic_spm_grass7\")\n# session = gj.init(\"~/grassdata\", \"nc_basic_spm_grass7\", \"PERMANENT\")\n\nWe are now within a GRASS project, let’s obtain information about it, like CRS details, region settings, list of raster and vector maps, etc.\n\n# Print project's CRS\ngs.parse_command(\"g.proj\", flags=\"g\")[\"srid\"]\n\n\n# Print computational region\ngs.region()\n\n\n# List raster maps\ngs.list_grouped([\"raster\"])\n\nLet’s obtain metadata about the elevation raster map.\n\n# Raster info\ngs.raster_info(\"elevation\")\n\nIf we would only need to know or use the minimum value of the elevation raster, we can get it as follows:\n\ngs.raster_info(\"elevation\")[\"min\"]\n\nLet’s now visualize raster and vector maps with a different grass.jupyter class, the non-interactive Map class. This class creates and displays GRASS maps as PNG files. We basically instantiate the class first, add maps and maps’ elements and finally show the result. There are 2 ways of calling display (d.*) modules:\n\nreplace . by _ as in m.d_rast()\nuse run() as in m.run(\"d.rast\")\n\n\n# Instantiate the Map class\nm = gj.Map(width=400)\n\nThe Map class will by default use the first raster or vector extent to set the display extent. You could however also use the current computational region with use_region=True or call a previously saved computational region (different than the current) with the argument saved_region.\n\n# Add maps and map elements\nm.d_rast(map=\"elevation\")\nm.d_vect(map=\"streams\")\nm.d_legend(raster=\"elevation\", at=(50, 95, 85, 90), flags=\"b\")\n\n\n# Display the result\nm.show()\n\nWe can save our displayed maps by calling the save() method, i.e., m.save(). For the Map class it will output a PNG file, while for the InteractiveMap class an HTML.\n\nGRASS GIS & NumPy\nLet’s now see how to convert our GRASS rasters into numpy arrays. Having our raster maps as numpy arrays opens up a world of possibilities in terms of visualization and data analysis and modeling. We won’t go into anything complex here, but we’ll show how to read rasters into numpy arrays, plot them, modify them and then write them back into GRASS.\n\n# Import required libraries\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom grass.script import array as garray\n\n\n# Read elevation as numpy array\nelev = garray.array(mapname=\"elevation\", null=\"nan\")\nprint(elev.shape)\n\n\n# Estimate array average\nprint(np.average(elev))\n\n\n# Plot elev histogram\nsns.set_style('darkgrid')\nsns.histplot(data=elev.ravel(), labkde=True)\n\nLet’s modify our array and write it back into GRASS GIS. For this, we create a new copy of the GRASS elevation map first as shown below.\n\nelev_2 = garray.array(mapname=\"elevation\")\nelev_2 *= 2\n\n\n# Plot elev*2\nsns.histplot(data=[elev.ravel(), elev_2.ravel()], kde=True)\nplt.legend(labels=[\"elevation * 2\", \"elevation\"])\n\n\nNow we write the modified array into a GRASS raster map and check it’s actually there.\n\nelev_2.write(mapname=\"elevation_2\", overwrite=True)\n\n\ngs.list_grouped(type=\"raster\", pattern=\"elev*\")\n\n\n\nGRASS GIS & Pandas\nLet’s now explore how to convert text outputs into pandas data frames. We will get elevation univariate statistics for each land use class and parse the output into a pandas data frame.\n\nimport pandas as pd\nfrom io import StringIO\n\n\nstats = gs.read_command(\"r.univar\",\n                        flags=\"t\",\n                        map=\"elevation\",\n                        zones=\"landuse\",\n                        separator=\"comma\")\ndf = pd.read_csv(StringIO(stats))\n\ndf\n\nNext, we plot the mean elevation per class as follows:\n\nplt.figure(figsize=(10, 5))\nplt.bar(df['label'], df['mean'])\nplt.ylabel('Elevation')\nplt.title('Mean elevation by land cover type')\nplt.xticks(rotation=90)\nplt.show()\n\nSimilarly, if we need to do analysis with the attributes of GRASS vector maps, it is also possible to read the attribute table as a pandas data frame. Let’s see an example with the census vector map:\n\ncensus = gs.parse_command(\"v.db.select\", map=\"census\", format=\"json\")[\"records\"]\ndf = pd.DataFrame(census)\ndf\n\nOnce the attribute table is a data frame, we can, e.g., filter data by a condition and plot the results.\n\nfam_size_3 = df[df[\"FAM_SIZE\"] &gt; 3.0]\n\n\nfam_size_3.plot.scatter(x=\"FAM_SIZE\", y=\"OWNER_U\")"
  },
  {
    "objectID": "content/tutorials/get_started/fast_track_grass_and_python.html#final-remarks",
    "href": "content/tutorials/get_started/fast_track_grass_and_python.html#final-remarks",
    "title": "Get started with GRASS & Python in Jupyter Notebooks",
    "section": "Final remarks",
    "text": "Final remarks\nIn this tutorial, we have demonstrated, with very simple examples, how to use GRASS GIS tools together with Python, putting a special focus on data import and export as well as format conversions. Expert GRASS or Python users can then implement their workflows combining tools accordingly.\nEnjoy! \n\n\nThe development of this tutorial was funded by the US National Science Foundation (NSF), award 2303651."
  }
]